# C0编译器

一个用纯C语言编写的C0编译器，实现了从词法分析到自动机构造的功能。

## 功能特性

### 1. 词法分析器（Lexical Analyzer）

词法分析器能够将源代码翻译成Token序列（二元组形式），并检测词法错误。

**支持的功能：**
- ✅ 关键字识别：`const`, `int`, `double`, `char`, `void`, `if`, `else`, `while`, `for`, `return`, `break`, `continue`, `struct`
- ✅ 标识符识别：支持字母、数字和下划线，以字母或下划线开头
- ✅ 整型常量：支持10进制（如`123`）和16进制（如`0xFF`）
- ✅ 浮点常量：支持小数和科学计数法（如`3.14`, `1.23e-5`）
- ✅ 字符常量：如`'a'`, `'\n'`
- ✅ 字符串常量：如`"Hello"`, 支持转义字符
- ✅ 注释识别：单行注释`//`和多行注释`/* */`
- ✅ 运算符识别：算术、关系、逻辑运算符
- ✅ 分隔符识别：括号、花括号、方括号、分号、逗号等
- ✅ 词法错误处理：检测并报告非法字符、未结束的字符串等

### 2. NFA/DFA构造（Automata Construction）

实现了正规式到NFA的转换、NFA到DFA的确定化，以及DFA的最简化。

**支持的功能：**
- ✅ 标识符正规式的NFA构造：`letter(letter|digit)*`
- ✅ NFA到DFA的转换：使用子集构造法（Subset Construction）
- ✅ DFA最简化：使用状态等价类划分算法
- ✅ 状态转换图输出：文本形式显示状态转换关系
- ✅ 状态转换矩阵输出：表格形式显示转换规则

## 编译和使用

### 编译项目

```bash
make
```

### 清理编译产物

```bash
make clean
```

### 使用方法

#### 1. 词法分析

对源文件进行词法分析，输出Token序列：

```bash
./c0compiler -l <source_file>
```

示例：
```bash
./c0compiler -l test_input.c
```

输出格式（二元组）：
```
<TOKEN_TYPE, lexeme> [值] (行: X, 列: Y)
```

#### 2. 显示NFA状态转换图

显示标识符正规式的NFA：

```bash
./c0compiler -n
```

#### 3. 显示DFA状态转换图

显示NFA确定化后的DFA：

```bash
./c0compiler -d
```

#### 4. 显示最简化DFA

显示最简化的DFA及状态转换矩阵：

```bash
./c0compiler -m
```

### 快捷命令

```bash
make show-nfa        # 显示NFA
make show-dfa        # 显示DFA  
make show-min-dfa    # 显示最简DFA
make test            # 运行测试（使用test_input.c）
```

## 项目结构

```
c0-compiler/
├── main.c          # 主程序，命令行参数解析
├── token.h         # Token类型定义
├── token.c         # Token操作函数实现
├── lexer.h         # 词法分析器接口
├── lexer.c         # 词法分析器实现
├── nfa_dfa.h       # NFA/DFA数据结构和接口
├── nfa_dfa.c       # NFA/DFA算法实现
├── Makefile        # 编译脚本
├── test_input.c    # 测试输入文件
└── README.md       # 项目说明文档
```

## 实现细节

### 词法分析器实现

词法分析器采用有限状态自动机的方式实现，主要状态包括：
- `STATE_START`: 初始状态
- `STATE_IDENTIFIER`: 标识符识别状态
- `STATE_NUMBER`: 数字识别状态
- `STATE_HEX_NUMBER`: 十六进制数识别状态
- `STATE_FLOAT`: 浮点数识别状态
- `STATE_EXPONENT`: 指数部分识别状态
- `STATE_STRING`: 字符串识别状态
- `STATE_CHAR`: 字符识别状态
- `STATE_COMMENT_LINE`: 单行注释状态
- `STATE_COMMENT_BLOCK`: 多行注释状态

### NFA/DFA算法实现

**标识符的正规式：** `letter(letter|digit)*`
- `letter = [a-zA-Z_]`
- `digit = [0-9]`

**NFA构造：**
- 状态0：初始状态
- 状态1：终态（接受状态）
- 转换：状态0通过letter到状态1，状态1通过letter或digit自环

**NFA到DFA转换（子集构造法）：**
1. 计算初始状态的ε闭包
2. 对每个未处理的DFA状态和输入符号：
   - 计算move操作
   - 计算ε闭包
   - 创建新的DFA状态或找到已存在的状态
3. 标记包含NFA终态的DFA状态为终态

**DFA最简化（状态等价类划分）：**
1. 初始划分：终态和非终态
2. 迭代细化：
   - 对每个划分中的状态对，检查是否可区分
   - 如果对相同输入转移到不同划分，则可区分
   - 将可区分的状态分到新的划分
3. 根据最终划分构造最简DFA

## 示例输出

### 词法分析示例

```
Token序列（二元组形式）:
========================================
<INT, int> (行: 1, 列: 1)
<IDENTIFIER, main> (行: 1, 列: 5)
<LPAREN, (> (行: 1, 列: 9)
<RPAREN, )> (行: 1, 列: 10)
<LBRACE, {> (行: 1, 列: 12)
<INT, int> (行: 2, 列: 5)
<IDENTIFIER, count> (行: 2, 列: 9)
<ASSIGN, => (行: 2, 列: 15)
<INT_CONST, 10> [值: 10] (行: 2, 列: 17)
<SEMICOLON, ;> (行: 2, 列: 19)
...
```

### NFA输出示例

```
=== NFA 状态转换图 ===
状态数量: 2
初始状态: 0
终态集合: {1}

状态转换:
起始状态 -> 目标状态 [符号]
--------------------------------
    0    ->    1     ['a']
    0    ->    1     ['b']
    ...
    1    ->    1     ['0']
    1    ->    1     ['1']
    ...
```

### DFA输出示例

```
=== DFA 状态转换图 ===
状态数量: 2
初始状态: 0
终态集合: {1}

状态转换:
起始状态 -> 目标状态 [符号]
--------------------------------
    0    ->    1     ['a']
    0    ->    1     ['b']
    ...
    1    ->    1     ['0']
    1    ->    1     ['1']
    ...
```

## 技术特点

1. **详细的代码注释**：所有函数和关键逻辑都有中文注释说明
2. **模块化设计**：词法分析、Token管理、自动机构造分别实现
3. **错误处理**：能够检测并报告词法错误
4. **灵活的输出**：支持多种输出格式（二元组、状态图、转换矩阵）
5. **标准C实现**：使用标准C99，无外部依赖

## 测试

项目包含测试文件`test_input.c`，涵盖了各种词法元素：
- 关键字
- 标识符（包含下划线）
- 整型常量（10进制和16进制）
- 浮点常量（包含科学计数法）
- 字符和字符串常量
- 注释（单行和多行）
- 各种运算符和分隔符

运行测试：
```bash
make test
```

## 作者与许可

本项目为教学目的开发，展示了编译原理中词法分析和自动机理论的实现。

## 参考资料

- 《编译原理》（龙书）
- 正规式、NFA、DFA相关算法
- 子集构造法（Subset Construction）
- Hopcroft最小化算法
